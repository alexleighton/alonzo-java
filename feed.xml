<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Alonzo</title>
    <description>Alonzo is a Java software project to code a Lambda Calculus interpreter. Alongside the code lives this blog dedicated to writing and teaching about what goes into writing the interpreter, and interesting coding choices.
</description>
    <link>/alonzo-java/</link>
    <atom:link href="/alonzo-java/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 19 Jul 2015 21:41:54 -0700</pubDate>
    <lastBuildDate>Sun, 19 Jul 2015 21:41:54 -0700</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Unit Testing Framework Foundations</title>
        <description>&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;

&lt;p&gt;I’m a big fan of automated testing, for many reasons. It provides the easiest and most reliable way to see if your code is working, aside from strong static typing. Further, in my experience, driving interface design from the perspective of making it easy to test tends to make for good interfaces.&lt;/p&gt;

&lt;p&gt;In order to test our interpreter, it will be helpful to have a testing framework which will automate the process of running tests, and collecting and presenting test results. This isn’t strictly necessary, as we could just ad-hoc design our tests, with a &lt;code&gt;println&lt;/code&gt; indicating success here and a &lt;code&gt;resultCode&lt;/code&gt; indicating failure there. I think we’ll have more confidence in our results if they’re all delivered the same way, through the same testing mechanisms.&lt;/p&gt;

&lt;p&gt;Now if you’ve ever designed a testing framework, you’ll have quickly realized that like every other piece of software, having automated tests to ensure your testing framework still works is important. But we’ve got a bit of a quandary. Testing your testing framework seems valuable, but also like we’re getting into a “turtles all the way down” situation. At some point, you have to trust that the code you’re writing is correct. In our case, I started with a dumb test to be driven by the framework, essentially testing correctness of the testing framework manually.&lt;/p&gt;

&lt;p&gt;The first test:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FooTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;firstTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertEquals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;github_sample_ref&quot;&gt;&lt;small&gt;&lt;a href=&quot;https://github.com/alexleighton/alonzo-java/blob/add2fe75a054079bad27765233a1bd566d7a3ebe//tst/alonzo/FooTest.java#L6-L12&quot;&gt;/tst/alonzo/FooTest.java&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;The call to the test runner:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TestRunner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FooTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;github_sample_ref&quot;&gt;&lt;small&gt;&lt;a href=&quot;https://github.com/alexleighton/alonzo-java/blob/add2fe75a054079bad27765233a1bd566d7a3ebe//tst/alonzo/TestingMain.java#L7-L11&quot;&gt;/tst/alonzo/TestingMain.java&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;I started with these two classes before writing any of the testing framework code. In general, I believe in the value of test-driven development. Without going too much into TDD and its positives and negatives, here’s a benefit I’ve found from practicing TDD. Driving the code from a test usually results in a better, more usable interface. So, in this instance, I wrote the test the way I wanted to write a test, and wrote the code to run the test in a way that seemed easy to run tests. Honestly, this top-down thinking is one of the hardest things for new developers to really grok and practice. It is key in choosing your abstractions well and in writing interfaces that you actually would want to use.&lt;/p&gt;

&lt;p&gt;So far, the architecture of the testing framework is relatively simple. The &lt;a href=&quot;https://github.com/alexleighton/alonzo-java/blob/add2fe75a054079bad27765233a1bd566d7a3ebe/tst/alonzo/unit/TestRunner.java&quot;&gt;&lt;code&gt;TestRunner&lt;/code&gt;&lt;/a&gt; collects tests, then runs them, collecting the &lt;a href=&quot;https://github.com/alexleighton/alonzo-java/blob/add2fe75a054079bad27765233a1bd566d7a3ebe/tst/alonzo/unit/TestResult.java&quot;&gt;&lt;code&gt;TestResults&lt;/code&gt;&lt;/a&gt;, and finally displaying those results. In order to run the tests, the &lt;code&gt;TestRunner&lt;/code&gt; makes use of the &lt;a href=&quot;https://github.com/alexleighton/alonzo-java/blob/add2fe75a054079bad27765233a1bd566d7a3ebe/tst/alonzo/unit/RunnableTest.java&quot;&gt;&lt;code&gt;RunnableTest&lt;/code&gt;&lt;/a&gt; class, which does all the heavy lifting. It searches the class for any methods labeled with the &lt;a href=&quot;https://github.com/alexleighton/alonzo-java/blob/add2fe75a054079bad27765233a1bd566d7a3ebe/tst/alonzo/unit/Test.java&quot;&gt;&lt;code&gt;@Test&lt;/code&gt;&lt;/a&gt; annotation, and the constructor. &lt;code&gt;RunnableTest&lt;/code&gt; implements the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html&quot;&gt;&lt;code&gt;Supplier&amp;lt;TestResult&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, by running the wrapped test and constructing a result. &lt;code&gt;RunnableTest&lt;/code&gt; works in concert with the static methods in &lt;a href=&quot;https://github.com/alexleighton/alonzo-java/blob/add2fe75a054079bad27765233a1bd566d7a3ebe/tst/alonzo/unit/Assert.java&quot;&gt;&lt;code&gt;Assert&lt;/code&gt;&lt;/a&gt; which throw &lt;a href=&quot;https://github.com/alexleighton/alonzo-java/blob/add2fe75a054079bad27765233a1bd566d7a3ebe/tst/alonzo/unit/AssertionFailureException.java&quot;&gt;&lt;code&gt;AssertionFailureException&lt;/code&gt;&lt;/a&gt; to indicate a test failure.&lt;/p&gt;

&lt;p&gt;Now we have a testing framework with which to test the code we write for the interpreter.&lt;/p&gt;
</description>
        <pubDate>Sun, 19 Jul 2015 00:00:00 -0700</pubDate>
        <link>/alonzo-java/testing/2015/07/19/unit-testing.html</link>
        <guid isPermaLink="true">/alonzo-java/testing/2015/07/19/unit-testing.html</guid>
        
        <category>unit</category>
        
        <category>testing</category>
        
        
        <category>testing</category>
        
      </item>
    
      <item>
        <title>Welcome &amp; Introduction</title>
        <description>&lt;h2 id=&quot;welcome&quot;&gt;Welcome&lt;/h2&gt;

&lt;p&gt;On this blog you will find posts that discuss the project. I will be detailing the design choices, highlighting interesting code, and generally helping anyone interested in the Lambda Calculus understand the language and how to write an interpreter for it.&lt;/p&gt;

&lt;p&gt;We’ll be starting from scratch with this project. Partly to satisfy anyone’s curiosity about &lt;em&gt;all&lt;/em&gt; of the pieces, and partly because I detest the Java package managers I’ve run across. So, all bets are off — if we need it, we’ll build it.&lt;/p&gt;

&lt;p&gt;Here are the things I’m taking for granted:&lt;/p&gt;

&lt;h2 id=&quot;program-dependencies&quot;&gt;Program Dependencies&lt;/h2&gt;

&lt;h3 id=&quot;make&quot;&gt;Make&lt;/h3&gt;

&lt;p&gt;I am using the &lt;em&gt;old-as-the-hills&lt;/em&gt; Make for coordinating the building, testing, and cleaning of the project. Yes, I agree, there are better build tools out there. However, I think Make wins for simplicity and ubiquity. Not using a Java package manager means that all code will be in source rather than compiled format, so linking dependencies together can be left to javac.&lt;/p&gt;

&lt;h3 id=&quot;java-8&quot;&gt;Java 8&lt;/h3&gt;

&lt;p&gt;I am using the newest version of Java and the JDK because I want to get more familiar with the new semantics and libraries in Java 8 (yay first-class functions!). My other motivation for using Java is to show what it looks like to implement a functional language (the Lambda Calculus) in an imperative language. Often you’ll see folks implement a toy functional language in another functional language. Some people find this to be cheating in a way, as certain functional languages (OCaml, Haskell) seem better suited to constructing compilers and interpreters.&lt;/p&gt;
</description>
        <pubDate>Sun, 12 Jul 2015 00:00:00 -0700</pubDate>
        <link>/alonzo-java/misc/2015/07/12/welcome.html</link>
        <guid isPermaLink="true">/alonzo-java/misc/2015/07/12/welcome.html</guid>
        
        <category>introduction</category>
        
        
        <category>misc</category>
        
      </item>
    
  </channel>
</rss>

